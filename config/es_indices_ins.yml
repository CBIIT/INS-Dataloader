# Datamodel commit fb6185a
Settings:
  number_of_shards: 1
  max_result_window: 5000
  max_inner_result_window: 500
  mapping.total_fields.limit: 2000
  max_ngram_diff: 30
  analysis:
    filter:
      my_filter:
        type: "ngram"
        min_gram: 3
        max_gram: 30
        token_chars:
          - "letter"
          - "digit"
          - "symbol"
          - "punctuation"
    analyzer:
      keyword_analyzer:
        type: "custom"
        tokenizer: "keyword"
        filter:
          - "lowercase"
      standard_analyzer:
        type: "custom"
        tokenizer: "whitespace"
        filter:
          - "lowercase"
          - "my_filter"

Indices:
  # Global search
  - index_name: ins_static_pages
    type: about_file
    mapping:
      page:
        type: search_as_you_type
      title:
        type: search_as_you_type
      primaryContentImage:
        type: text
      content:
        type: object

  - index_name: home_stats
    type: neo4j
    mapping:
      num_grants:
        type: integer
      num_programs:
        type: integer
      num_projects:
        type: integer
      num_publications:
        type: integer
    # Using OPTIONAL MATCH so that we get all Programs
    cypher_query: >
      MATCH (pg:program)
        OPTIONAL MATCH (pj:project)-[:projects_of_program]->(pg)
        OPTIONAL MATCH (g:grant)-[:grants_of_project]->(pj)
        OPTIONAL MATCH (pb:publication)-[:has_publication]->(pj)
      RETURN
        COUNT(DISTINCT g) AS num_grants,
        COUNT(DISTINCT pg) AS num_programs,
        COUNT(DISTINCT pj) AS num_projects,
        COUNT(DISTINCT pb) AS num_publications;

  # Grants are connected to Programs through Projects
  - index_name: grants
    type: neo4j
    mapping:
      grant_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      grant_id_sort:
        type: keyword
      application_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      fiscal_year:
        type: integer
      grant_title:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      grant_title_sort:
        type: keyword
      abstract_text:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      keywords: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      principal_investigators: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      principal_investigators_sort:
        type: keyword
      program_officers:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_officers_sort:
        type: keyword
      award_amount:
        type: integer
      nci_funded_amount:
        type: integer
      award_notice_date:
        type: date
        format: yyyy-MM-dd
      project_start_date:
        type: date
        format: yyyy-MM-dd
      project_end_date:
        type: date
        format: yyyy-MM-dd
      opportunity_number:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_name:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_city:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_state:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_country:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      # Programs
      programs:
        type: nested
        properties:
          focus_area: # list
            type: keyword
          cancer_type: # list
            type: keyword
          program_id:
            type: keyword
          program_name:
            type: keyword
      # Projects
      project_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      project_id_sort:
        type: keyword
    # Avoiding OPTIONAL MATCH so that we don't get null grants
    cypher_query: >
      MATCH (pg:program),
        (pj:project)-[:projects_of_program]->(pg),
        (g:grant)-[:grants_of_project]->(pj)
      WITH
        g.grant_id AS grant_id,
        apoc.text.regreplace(apoc.text.clean(g.grant_id), '[^\\p{Alpha}0-9]', '') AS grant_id_sort,
        g.application_id AS application_id,
        g.fiscal_year AS fiscal_year,
        g.grant_title AS grant_title,
        apoc.text.regreplace(apoc.text.clean(g.grant_title), '[^\\p{Alpha}0-9]', '') AS grant_title_sort,
        g.abstract_text AS abstract_text,
        g.keywords AS keywords,
        g.principal_investigators AS principal_investigators,
        apoc.text.regreplace(apoc.text.clean(g.principal_investigators), '[^\\p{Alpha}0-9]', '') AS principal_investigators_sort,
        g.program_officers AS program_officers,
        apoc.text.regreplace(apoc.text.clean(g.program_officers), '[^\\p{Alpha}0-9]', '') AS program_officers_sort,
        g.award_amount AS award_amount,
        g.nci_funded_amount AS nci_funded_amount,
        (CASE g.award_notice_date WHEN '' THEN NULL ELSE g.award_notice_date END) AS award_notice_date,
        (CASE g.project_start_date WHEN '' THEN NULL ELSE g.project_start_date END) AS project_start_date,
        (CASE g.project_end_date WHEN '' THEN NULL ELSE g.project_end_date END) AS project_end_date,
        g.opportunity_number AS opportunity_number,
        g.org_name AS org_name,
        g.org_city AS org_city,
        g.org_state AS org_state,
        g.org_country AS org_country,
        COLLECT(DISTINCT({
          focus_area: apoc.text.split(pg.focus_area, ';'),
          cancer_type: apoc.text.split(pg.cancer_type, ';'),
          program_id: pg.program_id,
          program_name: pg.program_name
        })) AS programs,
        pj.project_id AS project_id,
        apoc.text.regreplace(apoc.text.clean(pj.project_id), '[^\\p{Alpha}0-9]', '') AS project_id_sort
      RETURN
        grant_id,
        grant_id_sort,
        application_id,
        fiscal_year,
        grant_title,
        grant_title_sort,
        abstract_text,
        keywords,
        principal_investigators,
        principal_investigators_sort,
        program_officers,
        program_officers_sort,
        award_amount,
        nci_funded_amount,
        award_notice_date,
        project_start_date,
        project_end_date,
        opportunity_number,
        org_name,
        org_city,
        org_state,
        org_country,
        programs,
        project_id,
        project_id_sort;

  # Programs are many-to-many with Projects
  - index_name: programs
    type: neo4j
    mapping:
      program_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_id_sort:
        type: keyword
      program_name:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_name_sort:
        type: keyword
      program_acronym:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_acronym_sort:
        type: keyword
      data_link_and_program_acronym:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      data_link_and_program_acronym_sort:
        type: keyword
      focus_area: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      focus_area_sort:
        type: keyword
      focus_area_str:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      cancer_type: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      cancer_type_sort:
        type: keyword
      cancer_type_str:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      doc: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      doc_str:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      contact_pi:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      contact_pi_email:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      contact_nih:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      contact_nih_email:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      nofo: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      nofo_str:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      award: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      award_str:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_link:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_link_sort:
        type: keyword
      data_link:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      data_link_sort:
        type: keyword
    cypher_query: >
      MATCH (pg:program)
      WITH
        pg,
        (CASE pg.data_link
          WHEN '' THEN NULL
          ELSE pg.program_acronym
        END) AS data_link_and_program_acronym
      WITH
        pg.program_id AS program_id,
        apoc.text.regreplace(apoc.text.clean(pg.program_id), '[^\\p{Alpha}0-9]', '') AS program_id_sort,
        pg.program_name AS program_name,
        apoc.text.regreplace(apoc.text.clean(pg.program_name), '[^\\p{Alpha}0-9]', '') AS program_name_sort,
        pg.program_acronym AS program_acronym,
        apoc.text.regreplace(apoc.text.clean(pg.program_acronym), '[^\\p{Alpha}0-9]', '') AS program_acronym_sort,
        data_link_and_program_acronym,
        apoc.text.regreplace(apoc.text.clean(data_link_and_program_acronym), '[^\\p{Alpha}0-9]', '') AS data_link_and_program_acronym_sort,
        apoc.coll.sort(apoc.text.split(pg.focus_area, ';')) AS focus_area,
        pg.focus_area AS focus_area_str,
        apoc.text.regreplace(apoc.text.clean(pg.focus_area), '[^\\p{Alpha}0-9]', '') AS focus_area_sort,
        apoc.coll.sort(apoc.text.split(pg.cancer_type, ';')) AS cancer_type,
        pg.cancer_type AS cancer_type_str,
        apoc.text.regreplace(apoc.text.clean(pg.cancer_type), '[^\\p{Alpha}0-9]', '') AS cancer_type_sort,
        apoc.text.split(pg.doc, ';') AS doc,
        pg.doc AS doc_str,
        pg.contact_pi AS contact_pi,
        pg.contact_pi_email AS contact_pi_email,
        pg.contact_nih AS contact_nih,
        pg.contact_nih_email AS contact_nih_email,
        apoc.text.split(pg.nofo, ';') AS nofo,
        pg.nofo AS nofo_str,
        apoc.text.split(pg.award, ';') AS award,
        pg.award AS award_str,
        pg.program_link AS program_link,
        apoc.text.regreplace(apoc.text.clean(pg.program_link), '[^\\p{Alpha}0-9]', '') AS program_link_sort,
        pg.data_link AS data_link,
        apoc.text.regreplace(apoc.text.clean(pg.data_link), '[^\\p{Alpha}0-9]', '') AS data_link_sort
      RETURN
        program_id,
        program_id_sort,
        program_name,
        program_name_sort,
        program_acronym,
        program_acronym_sort,
        data_link_and_program_acronym,
        data_link_and_program_acronym_sort,
        focus_area,
        focus_area_str,
        focus_area_sort,
        cancer_type,
        cancer_type_str,
        cancer_type_sort,
        doc,
        doc_str,
        contact_pi,
        contact_pi_email,
        contact_nih,
        contact_nih_email,
        nofo,
        nofo_str,
        award,
        award_str,
        program_link,
        program_link_sort,
        data_link,
        data_link_sort;

  - index_name: faceted_projects
    type: neo4j
    mapping:
      project_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      # Programs
      focus_area:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      cancer_type:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_name:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
    cypher_query: >
      MATCH (pg:program)<-[:projects_of_program]-(pj:project)
      RETURN
        pj.project_id AS project_id,
        apoc.text.split(pg.focus_area, ';') AS focus_area,
        apoc.text.split(pg.cancer_type, ';') AS cancer_type,
        pg.program_id AS program_id,
        pg.program_name AS program_name;

  # Projects are many-to-many with Programs
  - index_name: projects
    type: neo4j
    mapping:
      project_id:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      project_id_sort:
        type: keyword
      project_title:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      project_title_sort:
        type: keyword
      abstract_text:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      project_start_date:
        type: date
        format: yyyy-MM-dd
      project_end_date:
        type: date
        format: yyyy-MM-dd
      opportunity_number:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_name:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_name_sort:
        type: keyword
      org_city:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_state:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      org_country:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      # Programs
      focus_area:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      cancer_type:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_acronyms:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_ids:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_names:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      program_names_sort:
        type: keyword
      programs:
        type: nested
        properties:
          focus_area: # list
            type: keyword
          cancer_type: # list
            type: keyword
          program_id:
            type: keyword
          program_name:
            type: keyword
    # Avoiding OPTIONAL MATCH so that we don't get null projects
    cypher_query: >
      MATCH (pg:program)<-[:projects_of_program]-(pj:project)
      WITH
        pg,
        pj,
        apoc.text.split(pg.focus_area, ';') AS focus_areas,
        apoc.text.split(pg.cancer_type, ';') AS cancer_type
      ORDER BY toLower(pg.program_name) ASC
      UNWIND focus_areas AS focus_area
      WITH
        pj.project_id AS project_id,
        apoc.text.regreplace(apoc.text.clean(pj.project_id), '[^\\p{Alpha}0-9]', '') AS project_id_sort,
        pj.project_title AS project_title,
        apoc.text.regreplace(apoc.text.clean(pj.project_title), '[^\\p{Alpha}0-9]', '') AS project_title_sort,
        pj.abstract_text AS abstract_text,
        (CASE pj.project_start_date WHEN '' THEN NULL ELSE pj.project_start_date END) AS project_start_date,
        (CASE pj.project_end_date WHEN '' THEN NULL ELSE pj.project_end_date END) AS project_end_date,
        pj.opportunity_number AS opportunity_number,
        pj.org_name AS org_name,
        apoc.text.regreplace(apoc.text.clean(pj.org_name), '[^\\p{Alpha}0-9]', '') AS org_name_sort,
        pj.org_city AS org_city,
        pj.org_state AS org_state,
        pj.org_country AS org_country,
        COLLECT(DISTINCT focus_area) AS focus_area,
        COLLECT(DISTINCT cancer_type) AS cancer_type,
        apoc.text.join(COLLECT(DISTINCT pg.program_acronym), ';') AS program_acronyms,
        apoc.text.join(COLLECT(DISTINCT pg.program_id), ';') AS program_ids,
        apoc.text.join(COLLECT(DISTINCT pg.program_name), ';') AS program_names,
        apoc.text.join(COLLECT(DISTINCT apoc.text.regreplace(apoc.text.clean(pg.program_name), '[^\\p{Alpha}0-9]', '')), '') AS program_names_sort,
        COLLECT(DISTINCT({
          focus_area: apoc.text.split(pg.focus_area, ';'),
          cancer_type: apoc.text.split(pg.cancer_type, ';'),
          program_id: pg.program_id,
          program_name: pg.program_name
        })) AS programs
      RETURN
        project_id,
        project_id_sort,
        project_title,
        project_title_sort,
        abstract_text,
        project_start_date,
        project_end_date,
        opportunity_number,
        org_name,
        org_name_sort,
        org_city,
        org_state,
        org_country,
        focus_area,
        cancer_type,
        program_acronyms,
        program_ids,
        program_names,
        program_names_sort,
        programs;

  # Publications are connected to Programs through Projects
  - index_name: publications
    type: neo4j
    mapping:
      pmid:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      pmid_sort:
        type: keyword
      title:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      title_sort:
        type: keyword
      authors: # list
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      authors_sort:
        type: keyword
      publication_date:
        type: date
        format: yyyy-MM-dd
      cited_by:
        type: integer
      relative_citation_ratio:
        type: float
      # Programs
      programs:
        type: nested
        properties:
          focus_area: # list
            type: keyword
          cancer_type: # list
            type: keyword
          program_id:
            type: keyword
          program_name:
            type: keyword
      # Projects
      projects:
        type: nested
        properties:
          project_id:
            type: keyword
      # Projects
      project_ids:
        type: keyword
        fields:
          sort:
            type: keyword
            normalizer: lowercase
      project_ids_sort:
        type: keyword
    # Avoiding OPTIONAL MATCH so that we don't get null publications
    cypher_query: >
      MATCH (pg:program),
        (pj:project)-[:projects_of_program]->(pg),
        (pb:publication)-[:has_publication]->(pj)
      WITH
        pb,
        pj,
        COLLECT(DISTINCT pg) AS programs,
        COLLECT(DISTINCT pj) AS projects
      ORDER BY toLower(pj.project_id) ASC
      UNWIND programs AS program
      UNWIND projects AS project
      WITH
        pb.pmid AS pmid,
        apoc.text.regreplace(apoc.text.clean(pb.pmid), '[^\\p{Alpha}0-9]', '') AS pmid_sort,
        pb.title AS title,
        apoc.text.regreplace(apoc.text.clean(pb.title), '[^\\p{Alpha}0-9]', '') AS title_sort,
        pb.authors AS authors,
        apoc.text.regreplace(apoc.text.clean(pb.authors), '[^\\p{Alpha}0-9]', '') AS authors_sort,
        (CASE pb.publication_date WHEN '' THEN NULL ELSE pb.publication_date END) AS publication_date,
        toInteger(pb.cited_by) AS cited_by,
        toFloat(pb.relative_citation_ratio) AS relative_citation_ratio,
        COLLECT(DISTINCT({
          focus_area: apoc.text.split(program.focus_area, ';'),
          cancer_type: apoc.text.split(program.cancer_type, ';'),
          program_id: program.program_id,
          program_name: program.program_name
        })) AS programs,
        COLLECT(DISTINCT({
          project_id: project.project_id
        })) AS projects,
        apoc.text.join(COLLECT(DISTINCT project.project_id), ';') AS project_ids,
         apoc.text.regreplace(apoc.text.clean(apoc.text.join(COLLECT(DISTINCT project.project_id), '')), '[^\\p{Alpha}0-9]', '') AS project_ids_sort
      RETURN
        pmid,
        pmid_sort,
        title,
        title_sort,
        authors,
        authors_sort,
        publication_date,
        cited_by,
        relative_citation_ratio,
        programs,
        projects,
        project_ids,
        project_ids_sort;
